üöÄ Kubernetes API Routing with NGINX Plus

Multi-API Deployment on Kubernetes with NGINX Plus

This project demonstrates how to deploy two independent NGINX-based APIs into a Kubernetes cluster and expose them via a single NGINX Ingress Controller.

API1 ‚Üí /api1/ ‚Üí returns Hello from API 1

API2 ‚Üí /api2/ ‚Üí returns Hello from API 2

Both applications are accessible through the same Ingress endpoint: http://mcs.com
.

üì° Cluster Architecture

3 Ubuntu VMs (1 control-plane, 2 workers)

Kubernetes v1.30.14 with containerd runtime

Calico CNI for pod networking and NetworkPolicy support

NGINX Plus Ingress Controller for external access and routing

Request Flow:
Client ‚Üí Ingress Controller (NGINX Plus) ‚Üí Service ‚Üí Pod (nginx container)

‚öôÔ∏è Cluster Setup
1. Initialize the Control Plane

On master node:

sudo kubeadm init --pod-network-cidr=10.244.0.0/16


Configure kubectl for your user:

mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

2. Join Worker Nodes

On each worker node:

sudo kubeadm join <MASTER_IP>:6443 --token <TOKEN> \
    --discovery-token-ca-cert-hash sha256:<HASH>

3. Install Calico CNI
kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/calico.yaml

4. Verify
kubectl get pods -n kube-system

üîë Installing NGINX Plus Ingress
1. Obtain NGINX Plus License

Download your nginx-repo.crt and nginx-repo.key from the MyF5 portal.

Copy them to your control-plane node.

2. Create Kubernetes Secret for License
kubectl create secret generic nginx-repo-secret \
  --from-file=nginx-repo.crt=./nginx-repo.crt \
  --from-file=nginx-repo.key=./nginx-repo.key

3. Add NGINX Plus Helm Repo
helm repo add nginx-stable https://pkgs.nginx.com/helm/nginx-stable
helm repo update

üìÇ Files
File	Purpose
api1.yaml	Deployment + HTML ConfigMap for API1
api2.yaml	Deployment + HTML ConfigMap for API2
configmap1.yaml	NGINX config for API1
configmap2.yaml	NGINX config for API2
svc1.yaml	ClusterIP Service for API1
svc2.yaml	ClusterIP Service for API2
ingress-controller-nginx.yaml	Ingress Controller configuration
svc-dashboard.yaml	Exposes NGINX Plus dashboard from master
‚öôÔ∏è How It Works
1. ConfigMaps (configmap1.yaml, configmap2.yaml)

Provide custom nginx.conf files:

API1 ‚Üí Listens on port 8000, serves at /api1

API2 ‚Üí Listens on port 8080, serves at /api2

2. Deployments (api1.yaml, api2.yaml)

Use the official nginx:latest image

Mount:

HTML content (index.html) from ConfigMap

Full NGINX config (nginx.conf) from ConfigMap

3. Services (svc1.yaml, svc2.yaml)

ClusterIP type (only accessible inside the cluster):

API1 ‚Üí forwards port 80 ‚Üí 8000

API2 ‚Üí forwards port 80 ‚Üí 8080

4. Ingress (ingress-controller-nginx.yaml)

Uses the NGINX Plus Ingress Controller

Routes traffic:

/api1 ‚Üí API1 Service

/api2 ‚Üí API2 Service

üöÄ Deployment

Apply all manifests:

kubectl apply -f configmap1.yaml
kubectl apply -f configmap2.yaml
kubectl apply -f api1.yaml
kubectl apply -f api2.yaml
kubectl apply -f svc1.yaml
kubectl apply -f svc2.yaml
kubectl apply -f svc-dashboard.yaml
kubectl apply -f ingress-controller-nginx.yaml


Check resources:

kubectl get pods
kubectl get svc
kubectl get ingress


Check NGINX Plus deployment in the nginx-ingress namespace:

kubectl get deploy -n nginx-ingress
kubectl get pod -n nginx-ingress
kubectl get svc -n nginx-ingress

üåç Accessing the APIs
1. Get Ingress Controller Service
kubectl get svc -n nginx-ingress


Example output:

NAME                           TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE
nic-nginx-ingress-controller   NodePort   10.110.200.140   <none>        80:31194/TCP,443:32277/TCP   5d


NodePort 31194 ‚Üí HTTP

NodePort 32277 ‚Üí HTTPS

2. Test APIs

Add the Host header (mcs.com):

curl -H "Host: mcs.com" http://<NodeIP>:31194/api1/
curl -H "Host: mcs.com" http://<NodeIP>:31194/api2/


‚úÖ Expected responses:

/api1/ ‚Üí Hello from API 1

/api2/ ‚Üí Hello from API 2

üìä Enabling the NGINX Plus Dashboard

The NGINX Plus Ingress Controller ships with a built-in live activity monitoring dashboard.
This provides real-time visibility into HTTP traffic, upstream health, and configuration state.

1. Enable Dashboard in Deployment

Edit the Ingress Controller Deployment:

kubectl edit deploy nic2-nginx-ingress-controller -n nginx-ingress


Ensure the following flags are set:

- -nginx-status=true
- -nginx-status-port=8080
- -nginx-status-allow-cidrs=0.0.0.0/0   # Allow access from all IPs (or restrict in prod)

2. Expose Dashboard via NodePort

Create a Service (svc-dashboard.yaml):

apiVersion: v1
kind: Service
metadata:
  name: nginx-plus-dashboard
  namespace: nginx-ingress
spec:
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 32080
  selector:
    app.kubernetes.io/name: nginx-ingress


Apply it:

kubectl apply -f svc-dashboard.yaml

3. Access the Dashboard

From your master node (or any cluster node):

http://<NodeIP>:32080/dashboard.html


You should now see the NGINX Plus Dashboard UI in your browser.

üõ† Troubleshooting

301 Redirects

Requesting /api1 without a trailing slash may cause a redirect to /api1/.

Fix: Use /api1/ or update nginx.conf.

404 Not Found

Path does not match Ingress rules.

Check: Service ports (targetPort: 8000 / 8080) and Ingress paths.

502 Bad Gateway

Usually a Service port mismatch.

Check: Deployment ‚Üí Service ‚Üí Ingress port consistency.

‚úÖ Summary

API1 available at: http://mcs.com:31194/api1/

API2 available at: http://mcs.com:31194/api2/

Dashboard available at: http://<NodeIP>:32080/dashboard.html

üëâ Now you can copy this entire Markdown into your README.md.

Would you like me to also prepare a GitHub-friendly Table of Contents at the top so users can jump to sections (Cluster Setup, Deployment, Dashboard, etc.)?
